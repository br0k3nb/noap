import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import nodemailer from 'nodemailer';

import User from '../models/User.js';
import Otp from '../models/OTP.js';
import 'dotenv/config';

import mailHTML from '../dataset/mailHTML.js';

const transporter = nodemailer.createTransport({
    service: "FastMail",
    auth: { user: process.env.HOST_MAIL, pass: process.env.HOST_MAIL_PASSWORD }
});

export default {
    async add(req, res) {
        try {
            const { name, email, password } = req.body;
            const userExists = await User.find({ email });

            if(userExists.length > 0) return res.status(400).json({message: 'User already exists, please sign in!'});

            const hashedPassword = await bcrypt.hash(password, 10);
            await User.create({ email, password: hashedPassword, name });
            res.status(200).json({message: 'User created successfully!'});
        } catch (err) {
            res.status(400).json({message: err});
        }
    },
    async login(req , res) {
        try {
            const { email, password } = req.body;
            const getUser = await User.find({ email });

            if(getUser.length === 0) return res.status(400).json({message: 'Wrong email or password combination!'});

            const passwordDB = getUser[0].password;
            const comparePasswords = await bcrypt.compare( password, passwordDB );

            if(comparePasswords) {
                const payload = {
                    iss: "login-form",
                    sub: {_id: getUser[0]?._id, name: getUser[0]?.name},
                    exp: Math.floor(Date.now() / 1000 + 6.048e+8),
                };

                const token = jwt.sign( payload, `${process.env.SECRET}`, { algorithm: 'HS256' });
                res.status(200).json({message: 'Success', token, _id: getUser[0]?._id, name: getUser[0]?.name});
            }
            else res.status(404).json({message: 'Wrong email or password combination!'});
        } catch (err) {
            res.status(400).json(err);
        }
    },
    async googleLogin(req , res) {
        try {
            const { email, name, id } = req.body;
            const getUser = await User.find({ email });

            if(getUser.length === 0) {
                await User.create({ name, email, googleId: id, googleAccount: true });

                const [ user ] = await User.find({ email }); //waiting to get the id generated by mongodb
                const { _id, googleAccount } = user;

                const payload = { iss: "login-form", sub: {_id, name}, exp: Math.floor(Date.now() / 1000 + 6.048e+8) };

                const token = jwt.sign( payload, `${process.env.SECRET}`, { algorithm: 'HS256' });
                res.status(200).json({message: 'Success', token, _id, name, googleAccount});
            }
            else if(getUser[0]?.googleAccount === false) res.status(400).json({ message: 'User already exists, please sign in using your email and password!' });
            else {
                const { _id, googleAccount } = getUser[0];
                const payload = { iss: "login-form", sub: {_id, name}, exp: Math.floor(Date.now() / 1000 + 6.048e+8) };
                const token = jwt.sign( payload, `${process.env.SECRET}`, { algorithm: 'HS256' });
                res.status(200).json({message: 'Success', token, _id, name, googleAccount});
            }
        } catch (err) {
            console.log(err);
            res.status(400).json({message: err});
        }
    },
    async convertIntoNormalAccount(req , res) {
        try {
            const { _id, password } = req.body;
            const getUser = await User.find({ _id });

            if(getUser.length === 0) res.status(400).json({message: 'User not found!'});

            else {
                const hashedPassword = await bcrypt.hash(password, 10);
                await User.findOneAndUpdate({_id}, {password: hashedPassword, googleAccount: false});
                res.status(200).json({message: 'Account was converted, please sign in again!'});
            }
        } catch (err) {
            console.log(err);
            res.status(400).json({message: err});
        }
    },
    async convertIntoGoogleAccount(req , res) {
        try {
            const { _id, email, name, id } = req.body;
            const getUser = await User.find({ _id });

            if(getUser.length === 0) res.status(400).json({message: 'User not found!'});

            else {
                const userAlreadyExist = await User.find({ email });

                if(userAlreadyExist.length > 0 &&
                    !userAlreadyExist[0].googleAccount &&
                    userAlreadyExist[0].email !== getUser[0].email
                ) return res.status(400).json({message: 'User already exists!'});

                await User.findOneAndUpdate({ _id }, { password: null, googleAccount: true, googleId: id, name, email });
                res.status(200).json({message: 'Google account was linked, please sign in again!'});
            }
        } catch (err) {
            res.status(400).json({message: err});
        }
    },
    async verifyUser(req, res) {
        try {
            const { password, _id } = req.body;
            const findUser = await User.findById({ _id });

            if(!findUser?._id) return res.status(400).json({ message: 'User not found!' });

            const userPassDB = findUser.password;
            const comparePass = await bcrypt.compare( password, userPassDB );

            if(comparePass) res.status(200).json({ message: 'Authenticated' });
            else res.status(400).json({ message: 'Wrong password, please try again!' });
        } catch (err) {
            console.log(err);
            res.status(400).json({ message: 'User not authenticated' });
        }
    },
    async changePassword(res, req) {
        try {
            const {userId, password} = res.body;
            const getUser = await User.find({ _id: userId });
            
            if(getUser.length === 0) return req.status(400).json({ message: 'User not found, please try again or later!' });

            const hashedPass = await bcrypt.hash(password, 10);
            await User.findOneAndUpdate({ _id: userId }, { password: hashedPass });

            req.status(200).json({ message: 'Password changed!'});
        } catch (err) {
           req.status(400).json({message: err});
        }
    },
    async findAndSendCode(req, res) {
        try {
            const { email } = req.body;
            const userExists = await User.find({ email });

            if(userExists.length === 0) return res.status(400).json({message: 'No users were found with this email address!', code: 1});

            const { _id, name, email: userMail} = userExists[0];

            const findOtp = await Otp.find({ userId: _id });
            const lastOtpDate = findOtp[findOtp.length - 1]?.createdAt;

            if(findOtp.length !== 0 && lastOtpDate.setDate(lastOtpDate.getDate() + 1) <= new Date) {
                await Otp.deleteMany({ userId: _id, id: findOtp.map(val => val._id) }); //removing all otps after 24 hours
            }

            if(findOtp.length === 0 || (findOtp.length < 5 && findOtp[findOtp.length - 1].spam < Date.now())) {
                const otpCode = `${Math.floor(1000 + Math.random() * 9000)}`;
                const hashedOtp = await bcrypt.hash(otpCode, 10);

                const message = {
                    from: process.env.HOST_MAIL,
                    to: userMail,
                    subject: 'OTP code verification',
                    html: mailHTML(otpCode, name)
                }

                transporter.sendMail(message, async (error) => {
                    if(error) res.status(500).json({ message: "Internal sever error, please try again or later", code: 2 });
                    else {
                        await Otp.create({
                            userId: _id,
                            otp: hashedOtp,
                            expiresAt: Date.now() + 3600000, //expires after 1 hour
                            spam: Date.now() + 120000 //adding spam protection of 2 minutes per email
                        });

                        res.status(200).json({ message: 'Email sent!', userId: _id });
                    }
                });
            }

            //if the user sent 5 emails and didn't verified the otp, then the user isn't allowed to sent more emails
            else if(findOtp.length === 5) {
                res.status(400).json({ message: 'Maximum number of otp codes exceeded, please verify your email!', code: 3 });
            }
            else res.status(400).json({ message: 'Wait at least a 2 minutes to send another email!', spam: findOtp[findOtp.length -1].spam, code: 4 });
        } catch (err) {
            res.status(400).json({message: err});
        }
    },
    async verifyOtp(res, req) {
        try {
            const { otp, userId } = res.body;
            const findOtp = await Otp.find({ userId });

            if(findOtp.length === 0) return req.status(400).json({ message: "Wrong OTP code, please try again!"});
            const compareOTPs = await bcrypt.compare(otp, findOtp[findOtp.length - 1].otp);

            if(compareOTPs && findOtp[findOtp.length - 1].expiresAt > Date.now()) {
                if(findOtp.length > 1) await Otp.deleteMany({ userId, id: findOtp.map(val => val._id)});
                else await Otp.findByIdAndDelete(findOtp[0]._id);

                return req.status(200).json({ message: "Verified!"});
            }
            else return req.status(400).json({ message: "Wrong OTP code, please try again!"});
        } catch (err) {
           req.status(400).json({message: err});
        }
    }
}